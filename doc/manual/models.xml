<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="chap-models">

	<title>Writing Disnix models</title>

        <para>
		In this section we explain how to write models that Disnix can use to
		automatically deploy a distributed system into a network of machines.
		We use the <code>StaffTracker</code> system as an example for this,
		which is a distributed system consisting of MySQL databases,
		Java web services and Java web applications. Other types of distributed
		systems can be deployed with Disnix as well. Other examples
		can be found in our Subversion repository:
		<link xlink:href="https://svn.nixos.org/repos/nix/disnix/examples">
			https://svn.nixos.org/repos/nix/disnix/examples
		</link>.
        </para>
        
	<section>
		<title>Background</title>
		
		<para>
			This example is a system which is used to manage staff of a
			university. For each staff member, the system can track
			its zipcode from the staff members' room number.
			From the zipcode it can determine the address of the
			building. From the IP address the system can determine
			the current location from the staff member.
			All the data repositories are stored in separate databases.
			Each data repository can be accessed by a web service.
		</para>
	</section>
        
	<section>
		<title>Architecture</title>
		
		<mediaobject>
			<imageobject>
				<imagedata fileref="stafftracker.png" format="PNG"/>
			</imageobject>
		</mediaobject>

		<para>
			The picture above shows the architecture of the 
			<code>StaffTracker</code> system.
			In the database layer, database components are shown,
			which store records such as zipcodes and staff members.
			In the web service layer, web service components are
			shown, which provide access to the data in de databases
			(the <code>GeolocationService</code> uses GeoIP to track a location).
			In the presentation layer, the <code>StaffTracker</code>
			web application front-end is shown, which can be 
			used by end users to manage staff of a university.
		</para>
		
		<para>
			All the components shown in the picture are
			<emphasis>distributable</emphasis> components (or services).
			For instance, the <code>GeolocationService</code> can
			be deployed on a different machine in the network as
			the <code>StaffTracker</code> web application front-end.
		</para>
	</section>
	
	<section>
		<title>Writing a Disnix expression</title>
		
		<para>
			Similar to writing a standard Nix expression for each package,
			every service also requires a expression which describes how to
			build it.
		</para>
		
		<para>
			This section shows you how a Disnix expression is written for
			a particular web service component of the <code>StaffTracker</code>
			system. Basically, a Disnix expression is very similar to an ordinary
			Nix expression, except that it is a nested function (which has two
			function headers instead of one). The headers represent 
			intra-dependencies and inter-dependencies repspectively,
			which both can be used to build and configure the service.
		</para>
		
		<example xml:id="ex-1-zipcode-service">
			<title>Disnix expression for the <code>ZipcodeService</code></title>
			<programlisting>
{stdenv, apacheAnt, axis2}: <co xml:id='co-1-outerFunctionHeader' />
{zipcodes}: <co xml:id='co-2-innerFunctionHeader' />

let
  contextXML = ''
    &lt;Context&gt;
      &lt;Resource name="jdbc/ZipcodeDB" auth="Container" type="javax.sql.DataSource"
                maxActivate="100" maxIdle="30" maxWait="10000"
                username="${zipcodes.target.mysqlUsername}" password="${zipcodes.target.mysqlPassword}" driverClassName="com.mysql.jdbc.Driver"
                url="jdbc:mysql://${zipcodes.target.hostname}:${toString (zipcodes.target.mysqlPort)}/${zipcodes.name}?autoReconnect=true" /&gt;
    &lt;/Context&gt; <co xml:id='co-3-contextXML' />
  '';
in
stdenv.mkDerivation { <co xml:id='co-4-mkDerivation' />
  name = "ZipcodeService";
  src = ../../../../services/webservices/ZipcodeService;
  buildInputs = [ apacheAnt ];
  AXIS2_LIB = "${axis2}/lib";
  AXIS2_WEBAPP = "${axis2}/webapps/axis2";
  buildPhase = "ant generate.war";
  installPhase = ''
    ensureDir $out/conf/Catalina
    cat > $out/conf/Catalina/ZipcodeService.xml &lt;&lt;EOF <co xml:id='co-5-cat-contextXML' />
    ${contextXML}
    EOF
    ensureDir $out/webapps
    cp *.war $out/webapps
  '';
}
			</programlisting>
		</example>
		
		<calloutlist>
			<callout arearefs='co-1-outerFunctionHeader'>
				 This is the outer function header, which specifies all the local dependencies,
				 or <emphasis>intra-dependencies</emphasis> of the service.
				 Intra-dependencies are all build-time and run-time dependencies
				 located on the same system. In order to build the <code>ZipcodeService</code>
				 a <varname>stdenv</varname> component is needed which is the standard
				 environment containing basic UNIX utilities and build environment,
				 such as <code>cat</code>, <code>ls</code> and <code>gcc</code>.
				 The <varname>apacheAnt</varname> argument specifies that we need
				 Apache Ant to compile the project, since it is written in Java
				 and requires Ant as a build tool. The <varname>axis2</varname> argument
				 refers to the Apache Axis2 library used to build web services.
			</callout>
			
			<callout arearefs='co-2-innerFunctionHeader'>
				  This is the inner function header, which specifies all the runtime dependencies
				  on distributable components, which we call <emphasis>inter-dependencies</emphasis>.
				  The <varname>zipcodes</varname> argument refers to a database in which all the
				  zipcodes are stored. The database may be running on a different machine as the
				  <code>ZipcodeService</code>.
			</callout>
			
			<callout arearefs='co-3-contextXML'>
				  This string contains a so-called context XML file. This is a configuration
				  file used by Apache Tomcat in order to configure web application specific settings.
				  One of these configuration settings are database settings.
				  In this string we use the inter-dependency parameter: <varname>zipcodes</varname>
				  to generate a JDBC connection string that can be used to connect to the
				  remote database. The <varname>zipcodes</varname> argument is an attribute set,
				  containing service and infrastructure properties, which can be used
				  to configure the web service. Each inter-dependency parameters contains
				  the attribute <varname>targets</varname> which contains a list of machines
				  and its properties on which the inter-dependency is deployed.
				  The <varname>target</varname> parameter is the first element from the 
				  <varname>targets</varname> list, other properties of are defined
				  in the services model of every service.
			</callout>
			
			<callout arearefs='co-4-mkDerivation'>
				  Like ordinary Nix expressions, we must call the derivation function to build something
				  from source code and to produce the output in the Nix store. It also requires
				  you to define attributes, such as <varname>name</varname> which is compulsory in
				  order to build a package from source code.
			</callout>
			
			<callout arearefs='co-5-cat-contextXML'>
				  Here, the context XML file defined earlier is written into a text file and included
				  with the generated web application so that the configuration settings can be
				  found by the Apache Tomcat web service. 
			</callout>
		</calloutlist>
	</section>
	
	<section>
		<title>Intra-dependency composition</title>
		
		<para>
			Like ordinary Nix expressions, we cannot use the expression in example 1 directly to build the
			service. We need to <emphasis>compose</emphasis> it by calling the function with the right arguments.
			In the case of Disnix, we need to call this function twice. First we have to compose this expression locally,
			by calling it with the required intra-dependency arguments. Later on, we have to compose it
			by using the inter-dependency arguments.
		</para>
		
		<example xml:id="ex-2-intra-dependency-composition">
			<title>Intra-dependency composition for the <code>StaffTracker</code></title>
			
			<programlisting>
{system ? builtins.currentSystem}:

let pkgs = import (builtins.getEnv "NIXPKGS_ALL") { inherit system; }; <co xml:id='co-1-importPkgs' />
in
with pkgs; <co xml:id='co-2-withPkgs' />

rec { <co xml:id='co-3-rec' />
### Databases

  rooms = import ../pkgs/databases/rooms {
    inherit stdenv;
  };
  
  staff = import ../pkgs/databases/staff {
    inherit stdenv;
  };
  
  zipcodes = import ../pkgs/databases/zipcodes {
    inherit stdenv;
  };

### Web services + Clients
    
  ZipcodeService = import ../pkgs/webservices/ZipcodeService { <co xml:id='co-4-composition' />
    inherit stdenv apacheAnt axis2;
  };
  
  ZipcodeServiceClient = import ../pkgs/webservices/ZipcodeServiceClient {
    inherit stdenv apacheAnt axis2;
  };
  ...
  
### Web applications

  StaffTracker = import ../pkgs/webapplications/StaffTracker {
    inherit stdenv apacheAnt axis2;
    inherit GeolocationServiceClient RoomServiceClient StaffServiceClient ZipcodeServiceClient;
  };
}
			</programlisting>
		</example>
		
		<calloutlist>
			<callout arearefs='co-1-importPkgs'>
				This line imports all the packages from Nixpkgs. This allows us to use various packages
				from the Nixpkgs repository such as the Java compiler and other compilers and libraries
				to build the components
			</callout>
			
			<callout arearefs='co-2-withPkgs'>
				This statement will make it easier to refer to packages defined in Nixpkgs.
				Otherwise you have to refer them by <code>pkgs.axis2</code> and so on.
			</callout>
			
			<callout arearefs='co-3-rec'>
				 Like the <code>pkgs/top-level/all-packages.nix</code> file in Nixpkgs, this composition expression
				 is also an mutually recursive attribute set in which attributes can refer to each other.
			</callout>
			
			<callout arearefs='co-4-composition'>
				Here, the expression from the previous example is imported and called with the right
				intra-dependency arguments.
			</callout>
		</calloutlist>
	</section>
	
	<section>
		<title>Services model</title>
		
		<para>
			Except for specifiying how to build a package from source code and what its local (intra) dependencies
			are, we also need to know what components are distributable, what their inter-dependencies are and
			how to activate or deactivate them. This is information captured in the services model.
		</para>
		
		<example>
			<title>Services model for the <code>StaffTracker</code></title>
			
			<programlisting>
{distribution, system}:

let pkgs = import ../top-level/all-packages.nix { inherit system; }; <co xml:id='co-1-importIntra' />
in
rec { <co xml:id='co-2-rec2' />
### Databases
  zipcodes = { 
    name = "zipcodes"; 
    pkg = pkgs.zipcodes; 
    dependsOn = {};
    type = "mysql-database";
  };
  ...
  
### Web services  

  ZipcodeService = { <co xml:id='co-3-service' />
    name = "ZipcodeService"; <co xml:id='co-4-serviceName' />
    pkg = pkgs.ZipcodeService; <co xml:id='co-5-pkg' />
    dependsOn = { <co xml:id='co-6-dependsOn' />
      inherit zipcodes;
    };
    type = "tomcat-webapplication"; <co xml:id='co-7-type' />
  };
  ...

### Web applications

  StaffTracker = {
    name = "StaffTracker";
    pkg = pkgs.StaffTracker;
    dependsOn = {
      inherit GeolocationService RoomService StaffService ZipcodeService;
    };
    type = "tomcat-webapplication";
  };
}
			</programlisting>
		</example>
		
		<calloutlist>
			<callout arearefs='co-1-importIntra'>
				Here, the expression from the previous example is imported so that we can use the
				intra-dependency compositions of the system. This is the expression shown
				in the previous example.
			</callout>
			
			<callout arearefs='co-2-rec2'>
				 Like the intra-dependency composition expression in the previous example,
				 the services expression is also a recursive attribute set in which attributes
				 can refer to each other.
			</callout>
			
			<callout arearefs='co-3-service'>
				 Every attribute represents a <emphasis>serivce</emphasis> (i.e. a distributable
				 component). These attributes represent to the components shown in the
				 architecture.
			</callout>
			
			<callout arearefs='co-4-serviceName'>
				Every service has a canonical name, so that it is known when invoking
				them from inter-dependency arguments.
			</callout>
			
			<callout arearefs='co-5-pkg'>
				For every service we need to know how to build it and what the intra-dependencies are. 
				This attribute refers to the function call that actually builds the service and
				its intra-dependencies from source code, which is defined in the previous example.
			</callout>
			
			<callout arearefs='co-6-dependsOn'>
				We also need to know for each service what the inter-dependencies are. In this
				case we specify that the attribute <varname>zipcodes</varname> (a service also
				defined in the services model) is an inter-dependency
				of the <code>ZipcodeService</code>. 
				By using Nix expression language constructs, you can also create different inter-dependency
				compositions. For instance by specifying: <code>zipcodes = mycustomzipcodes;</code>
				instead of <code>inherit zipcodes;</code>,
				you can configure the <code>ZipcodeService</code> to use a different database.
			</callout>
			
			<callout arearefs='co-7-type'>
				Finally, we must know how to activate and deactive a service. Since, services can represent
				many things such as a database or web application, we cannot perform this step generically.
				This attribute specifies the type of the web service, which will invoke a activation script
				on the target machine that performs the actual activation or deactivation process. 
				Various types are supported such as: <code>tomcat-webapplication</code> which will activate
				a web application on Apache Tomcat, <code>mysql-database</code> which will import
				a MySQL database schema on first startup and <code>process</code> which activates a generic
				UNIX process. Moreover a <code>wrapper</code> type exists, which allows the developer to include
				his own activation script inside the service.
			</callout>
		</calloutlist>
	</section>
	
	<section>
		<title>Infrastructure model</title>
		
		<para>
			Except for the services and their properties, we also need to know what machines are
			available and their relevant properties and capabilities, which is captured in the
			infrastructure model.
		</para>
		
		<example>
			<title>Infrastructure model</title>
			
			<programlisting>
{
  test1 = {
    hostname = "test1.example.org";
    tomcatPort = 8080;
    system = "i686-linux";
  };
  
  test2 = { <co xml:id='co-1-target' />
    hostname = "test2.example.org"; <co xml:id='co-2-hostname' />
    system = "x86_64-linux"; <co xml:id='co-3-system' />
    tomcatPort = 8080;
    mysqlPort = 3306; <co xml:id='co-4-mysqlPort' />
    mysqlUsername = "root";
    mysqlPassword = "admin";
    
  }; 
}
			</programlisting>
		</example>
		
		<calloutlist>
			  <callout arearefs='co-1-target'>
				  The infrastructure model is an attribute set in which each attribute represents a 
				  machine in the network.
			  </callout>
			  
			  <callout arearefs='co-2-hostname'>
				  In order to perform deployment steps remotely, we need to know how to connect
				  to the machine. The <code>hostname</code> attribute can be used for this.
			  </callout>
			  
			  <callout arearefs='co-3-system'>
				  A machine in the network may have a different architecture as the coordinator machine.
				  This attribute can be used to specify the architecture of the machine. By specifying
				  an architecture the coordinator will try to build the service for that particular
				  platform. In some cases the coordinator may not be able to do that. In such cases
				  you can either build the service on a target machine in the network or on a different
				  machine. Omitting the <code>system</code> attribute, will build the service for
				  the same architecture as the coordinator machine.
			  </callout>
			  
			  <callout arearefs='co-4-mysqlPort'>
				  The other properties of a machine can be freely chosen and are used by the
				  activation modules to activate a particular service. For instance, the
				  <code>mysqlPort</code> specifies on which port the MySQL can be reached.
			  </callout>
		</calloutlist>
		
		<para>
			Although you can specify what a network configuration looks like in an infrastructure model,
			you as a developer or system administrator must make sure that there are machine in the
			network match this configuration. There are some tools which can assist in this job, 
			for instance if only NixOS machines are used, an infrastructure model can be generated
			from a network of NixOS configurations.
		</para>
	</section>
	
	<section>
		<title>Distribution model</title>
		
		<para>
			We also have to specify for each service on which machine it must be deployed,
			which can be done in the distribution model.
		</para>
		
		<example>
			<title>Distribution model</title>
			
			<programlisting>
{infrastructure}:

{
  zipcodes = [ infrastructure.test2 ]; <co xml:id='co-1-zipcodes' />
  ZipcodeService = [ infrastructure.test1 ]; <co xml:id='co-2-ZipcodeService' />
  StaffTracker = [ infrastructure.test1 infrastructure.test2 ]; <co xml:id='co-3-StaffTracker' />
  ...
}
			</programlisting>
		</example>
		
		<calloutlist>
			<callout arearefs='co-1-zipcodes'>
				This attribute assignment states that the <code>zipcodes</code> service should be
				deployed on machine <code>test2</code>.
			</callout>
			
			<callout arearefs='co-2-ZipcodeService'>
				This attribute assignment states that the <code>ZipcodeService</code> service should be
				deployed on machine <code>test1</code>.
			</callout>
			
			<callout arearefs='co-3-StaffTracker'>
				This attribute assignment states that the <code>StaffTracker</code> service should be
				deployed on both <code>test1</code> and <code>test2</code>. By specifying multiple
				machines you can implement features such as a fallback mechanism or load balancing.
			</callout>
		</calloutlist>
	</section>
</chapter>
