<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="chap-basicusage">

	<title>A basic usage scenario</title>

        <para>
		In this chapter, we show a basic Disnix usage scenario. The purpose of this chapter is to demonstrate
		how to write simple models capturing various deployment aspects of a service-oriented system,
		and how to use Disnix to automatically deploy such a configuration to
		a network of machines.
	</para>
	<para>
		We use a particular flavour of the <link xlink:href="https://github.com/svanderburg/disnix-stafftracker-java-example">StaffTracker</link>
		system as an example, which is a toy system consisting of MySQL databases,
		Java web services, and Java web applications. Other types of service-oriented
		systems, with different types of components, can be deployed by Disnix as well, such
		as PHP web applications and UNIX processes. There are other StaffTracker variants available
		implementing the same concepts using different kinds of technologies.
	</para>
	<para>
		Some examples (including the <code>StaffTracker</code>)
		can be found on my Github page:
		<link xlink:href="https://github.com/svanderburg?tab=repositories">https://github.com/svanderburg?tab=repositories</link>.
        </para>
        
	<section>
		<title>Background</title>
		
		<para>
			The example used in this section is a system which is used to manage staff of a
			fictional university. This system stores various kinds of records about staff members, such as their
			names, room numbers and IP addresses.
		</para>
		<para>
			The system can determine
			a zipcode from the staff member's room number.
			From the zipcode it can determine the address of the
			building. From the IP address of a staff member, the system can determine
			the current location of the staff member.
			All the data repositories are stored in separate databases.
			Each data repository can be accessed through a web service.
		</para>
	</section>
        
	<section>
		<title>Architecture</title>
		
		<figure xml:id="fig-stafftracker">
			<title>Architecture of the <code>StaffTracker</code></title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="stafftracker.png" format="PNG"/>
				</imageobject>
			</mediaobject>
		</figure>
		
		<para>
			<xref linkend="fig-stafftracker" /> shows the architecture of the 
			<code>StaffTracker</code> system. The
			architecture consists of three layers: 
			a <emphasis>data layer</emphasis>, <emphasis>service layer</emphasis> and <emphasis>presentation layer</emphasis>.
			The database layer contains MySQL databases,
			storing data records such as zipcodes and staff members.
			The web service layer contains web service components, which expose
			create, read, update and delete operations for each data set
			(the <code>GeolocationService</code> uses GeoIP to track a location).
			In the presentation layer, the <code>StaffTracker</code>
			web application front-end is shown, that can be 
			used by end users to manage staff of a university.
		</para>
		
		<para>
			All the components shown in the picture are
			<emphasis>distributable</emphasis> deployment units (or services).
			For instance, the <code>GeolocationService</code> can
			be deployed to a different machine in the network as
			the <code>StaffTracker</code> web application front-end.
			The arrows denote inter-dependency relationships. Inter-dependency
			correspond to network links between services. In this particular example, they
			are SOAP/HTTP or plain TCP connections.
		</para>
	</section>
	
	<section>
		<title>Writing Disnix deployment models</title>
		
		<para>
			The Nix package manager builds components from specifications called
			Nix expressions, written in the Nix expression language.
			Disnix also uses the Nix expression language to capture deployment aspects and defines service builds in a quite similar way.
			In this section, we first show how an
			ordinary Nix expression is written. Then we explain how this concept
			is extended to service-oriented systems.
		</para>
		
		<section>
			<title>A basic Nix example</title>
			
			<example xml:id="ex-hello">
				<title>Nix expression for the GNU Hello package</title>
<programlisting>
{stdenv, fetchurl, perl}: <co xml:id='co-functionHeader' />

stdenv.mkDerivation { <co xml:id='co-mkDerivation' />
  name = "hello-2.1.1"; <co xml:id='co-name' />
  src = fetchurl { <co xml:id='co-src' />
    url = ftp://ftp.gnu.org/gnu/hello/hello-2.1.1.tar.gz;
    md5 = "70c9ccf9fac07f762c24f2df2290784d";
  };
  buildInputs = [ perl ]; <co xml:id='co-buildInputs' />

  meta = { <co xml:id='co-meta' />
    description = "GNU Hello, a classic computer science tool";
    homepage = http://www.gnu.org/software/hello/;
  };
}
</programlisting>
			</example>
		
			<para>
				<xref linkend="ex-hello" /> shows a Nix expression for the GNU Hello package,
				a trivial example package containing the <command>hello</command> command
				showing the famous "Hello World" quote.
			</para>
		
			<calloutlist>
				<callout arearefs='co-functionHeader'>
					<para>
						A Nix expression defines a function in which every
						argument represents a dependency to build a package. This particular example takes three arguments:
						<itemizedlist>
							<listitem>
								<simpara>
									<varname>stdenv</varname> is a package representing a standard
									environment containing a set of basic UNIX build utilities,
									such as <command>cat</command>, <command>ls</command> and <command>gcc</command>.
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									The <varname>fetchurl</varname> argument refers to a function that
									is used to download a source tarball from a particular URL.
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									The <varname>perl</varname> argument corresponds to the Perl interpreter.
								</simpara>
							</listitem>
						</itemizedlist>
					</para>
				</callout>
				
				<callout arearefs='co-mkDerivation'>
					<para>
						In the body of the function, we invoke <code>stdenv.mkDerivation</code>
						which is used to compose an isolated environment in which a build is performed.
						In this example, we have not specified the build steps that must be
						executed to build the package.
						If no build steps are given, then the builder assumes that this package is a GNU Autotools based
						package and basically executes the following instructions:
						<code>./configure; make; make install</code>.
					</para>
				</callout>
				
				<callout arearefs='co-name'>
					<para>
						Every package requires a name, which becomes part
						of the filename of the resulting package filename in the Nix store. It also gives a user
						the option to look it up after it has been installed.
					</para>
				</callout>
				
				<callout arearefs='co-src'>
					<para>
						This attribute specifies the location of source code that we want to compile. In our example,
						it is bound to the result of the <varname>fetchurl</varname>
						function invocation, which downloads the GNU Hello source tarball from the GNU FTP
						site. The MD5 hash is used to verify whether the source tarball matches the expected version.
					</para>
				</callout>
				
				<callout arearefs='co-buildInputs'>
					<para>
						This attribute is used to specify which packages must be used
						in the build environment. In our example, <command>perl</command> has been provided
						as a build input. The builder automatically sets the <varname>PATH</varname>
						and <varname>PERL5LIB</varname> environment variables, so that Perl can be found by
						build process that is executed in the builder environment. Not providing a
						dependency also makes it (nearly) impossible for a build process to find it.
					</para>
				</callout>
				
				<callout arearefs='co-meta'>
					<para>
						We can also specify some meta data for a package, so that we have a description
						and other useful information, such as the homepage and a license. These properties are not used
						while building the package.
					</para>
				</callout>
			</calloutlist>
		
			<para>
				Although the expression in <xref linkend="ex-hello" /> defines how to build a package from source code
				and its dependencies, we cannot use this expression to build the package directly because we do not
				know which version/variant of the dependencies we want to use, such as the version of Perl.
				Therefore, we have to <emphasis>compose</emphasis> the package in a seperate expression, in which we call
				the function shown ealier with its required parameters.
			</para>
		
			<example xml:id="ex-all-packages">
				<title><filename>all-packages.nix</filename>: Partial composition expression</title>
				
				<programlisting>
rec { <co xml:id='co-rec' />
  stdenv = ...;
  
  fetchurl = ...;
  
  perl = import ../pkgs/perl { <co xml:id='co-importPerl' />
    inherit stdenv fetchurl;
  };
  
  hello = import ../pkgs/hello { <co xml:id='co-importHello' />
    inherit stdenv fetchurl perl;
  };
  
  ...
}
				</programlisting>
			</example>
		
			<para>
				<xref linkend="ex-all-packages" /> shows a partial composition expression, in which the GNU Hello
				build function is called with its required function arguments. Moreover, all the other packages where GNU Hello depends
				on are also composed in this expression.
			</para>
		
			<calloutlist>
				<callout arearefs='co-rec'>
					<para>
						This expression is a mutually recursive attribute set in which attributes can refer to each other.
						Without recursion, we cannot pass attributes in this set as function parameters.
					</para>
				</callout>
				
				<callout arearefs='co-importHello'>
					<para>
						Here, the expression defined in <xref linkend="ex-hello" /> is imported and called
						with the its required function parameters. The corresponding dependencies are
						composed in the same composition expression shown in <xref linkend="ex-all-packages" />.
					</para>
					<para>
						We can also use the function parameters to make different kinds of compositions of the same package.
						For example, by replacing <code>inherit perl;</code> (which is syntactic sugar for <code>perl = perl;</code>)
						with <code>perl = perl54;</code> we can build GNU Hello using a different version of Perl.
					</para>
				</callout>
				
				<callout arearefs='co-importPerl'>
					<para>
						All the dependencies of the GNU Hello package, such as the Perl interpreter
						are composed in this expression as well.
					</para>
				</callout>
			</calloutlist>
			
			<para>
				There is often a lot of boilerplate code that must be written to compose packages. However, in most
				cases, the function arguments of each package correspond to attributes with the same name. The <code>callPackage {}</code>
				function can be used to automatically compose the package by
				providing the compositions with the same names as the function arguments. Using this function considerably reduces the amount
				of code that must be written.
			</para>
			
			<example xml:id="ex-all-packages-simplified">
				<title><filename>all-packages.nix</filename>: Simplified partial composition expression</title>
				
				<programlisting>
rec {
  stdenv = ...;
  
  fetchurl = ...;
  
  perl = callPackage ../pkgs/perl { };
  
  hello = callPackage ../pkgs/hello { };
  
  ...
}
				</programlisting>
			</example>
			
			<para>
				<xref linkend="ex-all-packages-simplified" /> shows a simplified equivalent of the previous composition expression
				using <code>callPackage {}</code>.
			</para>
		</section>
		
		<section>
			<title>Writing a Disnix expression for a service</title>
			
			<para>
				Similar to writing a Nix expressions for arbitrary packages,
				every service deployed by Disnix also requires a expression describing how to
				build it from source code and its dependencies. A Disnix expression is
				nearly identical to an ordinary Nix expression. Its only difference is that it also
				takes inter-dependencies into account while configuring or building a component.
			</para>
			
			<example xml:id="ex-zipcode-service">
				<title>Disnix expression for the <code>ZipcodeService</code></title>
<programlisting>
{stdenv, apacheAnt, axis2}: <co xml:id='co-outerFunctionHeader' />
{zipcodes}: <co xml:id='co-innerFunctionHeader' />

let
  contextXML = ''
    &lt;Context&gt;
      &lt;Resource name="jdbc/ZipcodeDB" auth="Container" type="javax.sql.DataSource"
                maxActivate="100" maxIdle="30" maxWait="10000"
                username="${zipcodes.target.container.mysqlUsername}" password="${zipcodes.target.container.mysqlPassword}" driverClassName="com.mysql.jdbc.Driver"
                url="jdbc:mysql://${zipcodes.target.properties.hostname}:${toString (zipcodes.target.container.mysqlPort)}/${zipcodes.name}?autoReconnect=true" /&gt;
    &lt;/Context&gt; <co xml:id='co-contextXML' />
  '';
in
stdenv.mkDerivation { <co xml:id='co-mkDerivation-service' />
  name = "ZipcodeService";
  src = ../../../../services/webservices/ZipcodeService;
  buildInputs = [ apacheAnt ];
  AXIS2_LIB = "${axis2}/lib";
  AXIS2_WEBAPP = "${axis2}/webapps/axis2";
  buildPhase = "ant generate.war";
  installPhase = ''
    ensureDir $out/conf/Catalina
    cat > $out/conf/Catalina/ZipcodeService.xml &lt;&lt;EOF <co xml:id='co-cat-contextXML' />
    ${contextXML}
    EOF
    ensureDir $out/webapps
    cp *.war $out/webapps
  '';
}
</programlisting>
			</example>
			
			<para>
				<xref linkend="ex-zipcode-service" /> shows a Disnix expression for
				a particular web service component of the <code>StaffTracker</code>
				system, called <code>ZipcodeService</code>, which provides access
				to records in the <code>zipcode</code> database.
				A Disnix expression is a nested function (having two
				function headers instead of one).
			</para>
		
			<calloutlist>
				<callout arearefs='co-outerFunctionHeader'>
					<para>
						This is the outer function header, which specifies all the local dependencies,
						or <emphasis>intra-dependencies</emphasis>.
						Intra-dependencies are all build-time and run-time dependencies
						located on the same system:
						<itemizedlist>
							<listitem>
								<simpara>
									<varname>stdenv</varname> is provides an environment containing
									basic UNIX utilities and build environment.
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									The <varname>apacheAnt</varname> argument refers to
									Apache Ant that is required to compile the project.
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									The <varname>axis2</varname> argument
									refers to the Apache Axis2 library that is used to
									implement web services.
								</simpara>
							</listitem>
						</itemizedlist>
					</para>
				</callout>
				
				<callout arearefs='co-innerFunctionHeader'>
					<para>
						This is the inner function header, which defines all the <emphasis>inter-dependencies</emphasis>.
						The <varname>zipcodes</varname> argument refers to a database in which all the
						zipcodes are stored. The database may be running on a different machine as the
						<code>ZipcodeService</code>. The service establishes a TCP connection to the database.
					</para>
					<para>
						Each inter-dependency parameter is an attribute set, which properties are taken
						from the services model, shown in the section.
					</para>
					<para>
						In addition, each inter-dependency parameter provides an attribute named <varname>targets</varname> referring
						to list of target machines to which the inter-dependency has been deployed. This mapping is
						defined in the distribution model shown later in this chapter.
						In the majority of cases, an inter-dependency only maps to one
						machine. The attribute <varname>target</varname> refers to the first list element for convenience.
					</para>
					<para>
						Each target attribute set defines two properties. The <varname>properties</varname> attribute refers to general
						machine properties and correspond to the properties attribute defined in the infrastructure model.
						The <varname>container</varname> attribute refers to the set of container properties to which the services
						has been deployed.
					</para>
				</callout>
				
				<callout arearefs='co-contextXML'>
					<para>
						This string composes a so-called context XML file. This is a configuration
						file used by Apache Tomcat to configure web application specific settings.
						One of these configuration settings are database settings.
					</para>
					<para>
						To compose this string, we use the inter-dependency parameter: <varname>zipcodes</varname>
						to generate a JDBC connection string that can be used to connect to the
						remote database. We use the machine-specific <varname>hostname</varname> attribute to determine
						the hostname to remotely connect and the <varname>container</varname> specific properties to fetch
						MySQL's port number and authentication credentials.
					</para>
				</callout>
				
				<callout arearefs='co-mkDerivation-service'>
					  <para>
						Like ordinary Nix expressions, we must call the derivation function to build a component
						from source code (that stores its build result in the Nix store). It also requires
						you to define similar build attributes, such as <varname>name</varname> that is used
						to identify a package.
					  </para>
				</callout>
				
				<callout arearefs='co-cat-contextXML'>
					  <para>
						Here, the context XML file defined earlier is written into a text file and bundled
						with the generated web application so that the configuration settings can be
						found by the Apache Tomcat web service. The Dysnomia module for Apache Tomcat
						takes care of the activation process.
					  </para>
				</callout>
			</calloutlist>
		
			<para>
				<xref linkend="ex-zipcode-service" /> shows you how to build and configure an Apache Axis2 web service.
				Other types of service may have different kinds configuration steps, but can also be configured and built
				by Disnix, like ordinary Nix packages.
				What Disnix basically provides is the locations of the inter-dependencies and the properties of
				the services and machines.
			</para>
		</section>
	
	
		<section>
			<title>Intra-dependency composition</title>
			
			<para>
				Like ordinary Nix expressions, we cannot use the expression in <xref linkend="ex-zipcode-service" /> directly to build the
				service. We need to <emphasis>compose</emphasis> it by calling the function with its required arguments.
				With Disnix, we need to compose a service twice. First, we have to compose this expression locally,
				by calling it with the required intra-dependency arguments. Later, we have to compose it
				using the inter-dependency arguments.
			</para>
			
			<example xml:id="ex-intra-dependency-composition">
				<title>Intra-dependency composition for the <code>StaffTracker</code></title>
			
<programlisting>
{system, pkgs}:

rec { <co xml:id='co-rec-intra' />
### Databases

  rooms = import ../pkgs/databases/rooms {
    inherit (pkgs) stdenv;
  };
  
  staff = import ../pkgs/databases/staff {
    inherit (pkgs) stdenv;
  };
  
  zipcodes = import ../pkgs/databases/zipcodes {
    inherit (pkgs) stdenv;
  };

### Web services + Clients
    
  ZipcodeService = import ../pkgs/webservices/ZipcodeService { <co xml:id='co-composition' />
    inherit (pkgs) stdenv apacheAnt axis2;
  };
  
  ZipcodeServiceClient = import ../pkgs/webservices/ZipcodeServiceClient {
    inherit (pkgs) stdenv apacheAnt axis2;
  };
  ...
  
### Web applications

  StaffTracker = import ../pkgs/webapplications/StaffTracker {
    inherit (pkgs) stdenv apacheAnt axis2;
    inherit GeolocationServiceClient RoomServiceClient StaffServiceClient ZipcodeServiceClient;
  };
}
</programlisting>
			</example>
			
			<para>
				<xref linkend="ex-intra-dependency-composition" /> shows a Nix expression in which
				services are composed locally by calling the expressions with its required intra-dependency arguments.
			</para>
			
			<calloutlist>
				<callout arearefs='co-rec-intra'>
					<para>
						Like the <filename>pkgs/top-level/all-packages.nix</filename> file in Nixpkgs, this composition expression
						is a mutually recursive attribute set in which attributes can refer to each other.
					</para>
				</callout>
				
				<callout arearefs='co-composition'>
					<para>
						Here, the expression from <xref linkend="ex-zipcode-service" /> is imported and called with the right
						intra-dependency arguments. The dependencies are either defined in the same model or in Nixpkgs.
					</para>
				</callout>
			</calloutlist>
			
			<para>
				We can also simplify the intra-dependency composition by composing our custom <code>callPackage {}</code> function:
			</para>
			
			<example xml:id="ex-intra-dependency-composition-simplified">
				<title>Simplified intra-dependency composition for the <code>StaffTracker</code></title>
<programlisting>
{system, pkgs}:

let
  callPackage = pkgs.lib.callPackageWith (pkgs // self); <co xml:id='co-callPackage' />
  
  self = {
  ### Databases
    rooms = callPackage ../pkgs/databases/rooms { };
  
    staff = callPackage ../pkgs/databases/staff { };
  
    zipcodes = callPackage ../pkgs/databases/zipcodes { };

  ### Web services + Clients
    ZipcodeService = callPackage ../pkgs/webservices/ZipcodeService { };
  
    ZipcodeServiceClient = callPackage ../pkgs/webservices/ZipcodeServiceClient { };
    
    ...
  
  ### Web applications
    StaffTracker = callPackage ../pkgs/webapplications/StaffTracker { };
  };
}
</programlisting>
			</example>
			
			<para>
				In the simplified expression, we compose a custom <code>callPackage {}</code> function <xref linkend="co-callPackage" />
				that first consults <varname>self</varname> containing our custom intra-dependency compositions and then any package
				provided by Nixpkgs.
			</para>
		</section>
		
		<section>
			<title>Services model</title>
			
			<para>
				Apart from specifiying how to build packages and what its local (intra) dependencies
				are, we need to provide additional settings to allow it to be deployed into a network of machines.
				The distributed deployment aspects of the components of a service-oriented system are captured in the services model.
			</para>
			
			<example xml:id="ex-services-model">
				<title>Services model for the <code>StaffTracker</code></title>
<programlisting>
{system, pkgs, distribution, invDistribution}: <co xml:id='co-servicesHeader' />

let customPkgs = import ../top-level/all-packages.nix { inherit system; }; <co xml:id='co-importIntra' />
in
rec { <co xml:id='co-rec2' />
### Databases
  zipcodes = { 
    name = "zipcodes"; 
    pkg = customPkgs.zipcodes; 
    dependsOn = {};    
    type = "mysql-database";
  };
  ...
  
### Web services  

  ZipcodeService = { <co xml:id='co-service' />
    name = "ZipcodeService"; <co xml:id='co-serviceName' />
    pkg = customPkgs.ZipcodeService; <co xml:id='co-pkg' />
    dependsOn = { <co xml:id='co-dependsOn' />
      inherit zipcodes;
    };
    type = "tomcat-webapplication"; <co xml:id='co-type' />
  };
  ...

### Web applications

  StaffTracker = {
    name = "StaffTracker";
    pkg = customPkgs.StaffTracker;
    dependsOn = {
      inherit GeolocationService RoomService StaffService ZipcodeService;
    };
    type = "tomcat-webapplication";
  };
}
</programlisting>
			</example>
			
			<para>
				<xref linkend="ex-services-model" /> represents the services model of the <code>StaffTracker</code>
				system. This model is a function returning an attribute set in which each attribute corresponds to a distributable component
				in the architecture diagram, shown earlier in <xref linkend="fig-stafftracker" />.
			</para>
			
			<calloutlist>
				<callout arearefs='co-servicesHeader'>
					<para>
						A services expression is a function taking four arguments:
						<itemizedlist>
							<listitem>
								<simpara>
									The <varname>system</varname> parameter takes an identifier
									of a system architecture that we want to build a service for.
									An example of an identifier is: <code>i686-linux</code> representing
									a 32-bit <code>x86</code> Linux machine.
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									The <varname>pkgs</varname> parameter refers to the Nixpkgs collection for
									the corresponding system identifier. Nixpkgs contains a large collection of
									free and open source packages (including some proprietary ones).
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									The <varname>distribution</varname> parameter refers to the distribution model,
									in which services are mapped onto machines in the network (this model is explained
									later).
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									The <varname>invDistribution</varname> parameter refers to an inverse distribution model.
									In <xref linkend="chap-target-specific" /> we show how this model can be used to generate
									target-specific services.
								</simpara>
							</listitem>
						</itemizedlist>
					</para>
				</callout>
				
				<callout arearefs='co-importIntra'>
					<para>
						Here, the expression from <xref linkend="ex-intra-dependency-composition" /> is imported so that we can use the
						intra-dependency compositions of all packages implementing the services.
					</para>
				</callout>
				
				<callout arearefs='co-rec2'>
					<para>
						Like the intra-dependency composition expression in the previous example,
						the services expression is also a mutually recursive attribute set in which attributes
						can refer to each other. This is required to pass the services as inter-dependency
						arguments to each service.
					</para>
				</callout>
				
				<callout arearefs='co-service'>
					<para>
						Every attribute represents a <emphasis>service</emphasis> (i.e. a distributable
						component). Services correspond to the components shown in the
						architecture in <xref linkend="fig-stafftracker" />.
					</para>
				</callout>
				
				<callout arearefs='co-serviceName'>
					<para>
						Every service has a canonical name, so that it is known to which one is referred
						from the inter-dependency arguments. This name must match the attribute name.
					</para>
				</callout>
				
				<callout arearefs='co-pkg'>
					<para>
						For every service, we must know how to build it and what their intra- and inter-dependencies are. 
						This attribute refers to the intra-dependency closure of the service, which is composed in
						<xref linkend="ex-intra-dependency-composition-simplified" />.
					</para>
				</callout>
				
				<callout arearefs='co-dependsOn'>
					<para>
						We also need to know for each service what the inter-dependencies actually are. 
						Inter-dependencies correspond to the arrows shown in <xref linkend="fig-stafftracker" />.
					</para>
					<para>
						In this
						particular example, we specify that the attribute <varname>zipcodes</varname> (a service also
						defined in the services model) is an inter-dependency
						of the <code>ZipcodeService</code>. 
					</para>
					<para>
						Similar to intra-dependency parameters, you can also create different inter-dependency
						compositions. For instance by specifying: <code>zipcodes = mycustomzipcodes;</code>
						instead of <code>inherit zipcodes;</code> (syntactic sugar for 
						<code>zipcodes = zipcodes;</code>),
						you can configure the <code>ZipcodeService</code> to use a different database.
					</para>
				</callout>
				
				<callout arearefs='co-type'>
					<para>
						Finally, we must know how to activate and deactive a service. Since services can represent
						nearly anything, such as a database or web application, we cannot perform this step generically.
						This attribute specifies the type of the service, which is used by Disnix to consult the Dysnomia plugin
						on the target machine performing the corresponding non-generic deployment steps. 
					</para>
					<para>
						Various types of services are supported by Dysnomia, such as: <code>tomcat-webapplication</code> which will activate
						a web application on Apache Tomcat, <code>mysql-database</code> which will import
						a MySQL database schema on first startup and <code>process</code> which activates a generic
						UNIX process. Moreover, also a <code>wrapper</code> type exists, allowing a developer to include
						his own activation script inside a service.
					</para>
				</callout>
			</calloutlist>
		</section>
	
		<section>
			<title>Infrastructure model</title>
			
			<para>
				Besides the services of which a system consists, we need to know what machines are
				available and what their relevant properties and capabilities are. These attributes are captured in the
				infrastructure model.
			</para>
			
			<example xml:id="ex-infrastructure-model">
				<title>Infrastructure model</title>
			
<programlisting>
{
  test1 = {
    properties = {
      hostname = "test1.example.org";
    };
    
    containers = {
      tomcat-webapplication = {
        tomcatPort = 8080;
      };
    };
    
    system = "i686-linux";
  };
  
  test2 = { <co xml:id='co-target' />
    properties = { <co xml:id='co-target-properties' />
      hostname = "test2.example.org"; <co xml:id='co-hostname' />
    };
    
    containers = { <co xml:id='co-target-containers' />
      tomcat-webapplication = {
        tomcatPort = 8080;
      };
      
      mysql-database = {
        mysqlPort = 3306; <co xml:id='co-mysqlPort' />
        mysqlUsername = "root";
        mysqlPassword = "admin";
      };
    };
    
    system = "x86_64-linux"; <co xml:id='co-system' />
    numOfCores = 1; <co xml:id='co-numOfCores' />
    targetProperty = "hostname"; <co xml:id='co-targetProperty' />
    clientInterface = "disnix-ssh-client"; <co xml:id='co-clientInterface' />
  }; 
}
</programlisting>
			</example>
			
			<para>
				<xref linkend="ex-infrastructure-model" /> shows an infrastructure model describing two machines and their properties.
			</para>
			
			<para>
				The infrastructure model contains the following basic properties:
			</para>
			
			<calloutlist>
				<callout arearefs='co-target'>
					<para>
						The infrastructure model is an attribute set in which each attribute represents a 
						machine in the network. This attribute refers to the properties of a machine called
						<varname>test2</varname>.
					</para>
				</callout>
				
				<callout arearefs='co-target-properties'>
					<para>
						  Each target can define a set of properties describing arbitrary characteristics of a machine.
					</para>
				</callout>
				
				<callout arearefs='co-hostname'>
					<para>
						In order to perform deployment steps remotely, we need to know how to connect
						to the machine. By default, the <varname>hostname</varname> attribute is used for this.
						Disnix can be configured to use a different property as well through a command-line
						parameter or environment variable.
					</para>
				</callout>
				  
				<callout arearefs='co-target-containers'>
					<para>
						Besides general target properties, each service has a specific type and will be deployed
						to a container that can host them. The <varname>containers</varname> attribute set defines
						properties of each container. These container-specific properties are used both for building
						the service, and for activation and deactivation.
					</para>
				</callout>
				  
				<callout arearefs='co-mysqlPort'>
					<para>
						The <varname>mysqlPort</varname> specifies on which port the MySQL can be reached.
						The MySQL properties in this model are used by the MySQL Dysnomia module for activating
						or deactivating the database.
					</para>
				</callout>
			</calloutlist>
			
			<para>
				The infrastructure model also allows you to specify a number of advanced system properties. These properties are
				optional and typically reasonable default values are provided for them. They only need to be specified in special circumstances:
			</para>
			
			<calloutlist>
				<callout arearefs='co-system'>
					<para>
						A machine in the network may have a different system architecture as the coordinator machine.
						The <varname>system</varname> attribute can be used to specify the system architecture of a target machine.
					</para>
					<para>
						In some cases, Nix may not be able to build a service for a target machine directly, because it is incapable
						to run a compiler for that platform or it has no dedicated build machine with the
						right architecture to delegate the build to.
						In such cases, you can build the service on a target machine in the network.
					</para>
					<para>
						By omitting the <varname>system</varname> attribute, Disnix builds the service for
						the same architecture as the coordinator machine.
					</para>
					<para>
						This property is particularly useful when deploying to a heterogeneous network consisting of
						machines running various kinds of operating systems having various kinds of system architectures.
						You do not need a dedicated cluster of machines to build for these architecture, but you can
						reuse the existing deployment infrastructure.
					</para>
				</callout>
				
				<callout arearefs='co-numOfCores'>
					<para>
						In the activation phase, Disnix tries to concurrently activate as many services as possible.
						The <varname>numOfCores</varname> attribute can be used to indicate the amount of CPU cores available on
						the target machine. If, for example, this value is set to 2, Disnix tries to activate two services
						concurrently on this machine when possible.
					</para>
					<para>
						If this attribute is omitted, it will default to <code>1</code>.
					</para>
				</callout>
				<callout arearefs='co-targetProperty'>
					  <para>
						This is a reserved property defining which attribute in this attribute set
						specifies how to connect to this machine. If this attribute is not specified
						then the value provided by the <option>--target-property</option> parameter, or
						<envar>DISNIX_TARGET_PROPERTY</envar> environment variable is used, which
						defaults to <varname>hostname</varname>. See <xref linkend="chap-advanced-options" /> for more information.
					  </para>
				</callout>
				<callout arearefs='co-clientInterface'>
					  <para>
						This reserved property specifies which executable needs to be run to connect
						to the target machine. If this attribute is not specified then the value provided
						by the <option>--interface</option> parameter, or the <envar>DISNIX_CLIENT_INTERFACE</envar>
						environment variable is used, which defaults to <command>disnix-ssh-client</command>.
						See <xref linkend="chap-advanced-options" /> for more information.
					  </para>
				</callout>
			</calloutlist>
			
			<para>
				Besides specifying the available machines and their properties,
				you as a developer or system administrator has to responsibility that the machines in the
				network match the given configuration. There are some tools which can assist you while doing this job. 
				For instance, if only NixOS machines are used, an infrastructure model can be generated
				from a network of NixOS configurations.
			</para>
		</section>
	
		<section>
			<title>Distribution model</title>
			
			<para>
				Disnix also needs to know to which machine each service must be deployed. A distribution
				model is used to specify these mappings.
			</para>
			
			<example xml:id="ex-distribution-model">
				<title>Distribution model for the <code>StaffTracker</code></title>
			
<programlisting>
{infrastructure}:

{
  zipcodes = [ infrastructure.test2 ]; <co xml:id='co-zipcodes' />
  ZipcodeService = [ infrastructure.test1 ]; <co xml:id='co-ZipcodeService' />
  StaffTracker = [ infrastructure.test1 infrastructure.test2 ]; <co xml:id='co-StaffTracker' />
  ...
}
</programlisting>
			</example>
			
			<para>
				<xref linkend="ex-distribution-model" /> shows a distribution model for a particular
				deployment scenario of the <code>StaffTracker</code> system.
			</para>
			
			<calloutlist>
				<callout arearefs='co-zipcodes'>
					<para>
						This attribute assignment states that the <varname>zipcodes</varname> service should be
						deployed to machine <code>test2</code>.
						The machine and its properties can be accessed in a service build
						through the <varname>target</varname> property
						of an inter-dependency argument in a Disnix expression, such as
						<xref linkend="ex-zipcode-service" />.
					</para>
				</callout>
				
				<callout arearefs='co-ZipcodeService'>
					<para>
						This attribute assignment states that the <code>ZipcodeService</code> service should be
						deployed to machine <code>test1</code>.
					</para>
				</callout>
				
				<callout arearefs='co-StaffTracker'>
					<para>
						This attribute assignment states that the <code>StaffTracker</code> service should be
						deployed to both <varname>test1</varname> and <varname>test2</varname>. Specifying multiple
						machines is useful for deploying redundant services, that can be used as a fallback or reached by load balancer.
						The list of machines can be accessed in a service build by referencing the <varname>targets</varname> property
						of an inter-dependency argument in a Disnix expression, such as
						<xref linkend="ex-zipcode-service" />.
					</para>
				</callout>
			</calloutlist>
			
			<para>
				As may be obsevered in the distribution model, each service is mapped to a target machine. Each service is supposed
				to be deployed to a container (predeployed to a machine) that is capable of hosting the service.
				By default, Disnix uses an auto-mapping strategy to determine to which container a service gets deployed.
				In principle, the container has the same name as the type to which the service belongs.
				In most cases, automapping suffices -- you typically only run one instance of a MySQL DBMS or Apache Tomcat service
				on one machine.
			</para>
			<para>
				In some unconventional cases, it may be desired to run multiple instances of the same container on one machine, e.g. two MySQL DBMSes or two Apache
				Tomcat services. In such cases, more control in the distribution model needed. Disnix also supports an alternative (and more verbose)
				distribution model notation in which the container mapping can be specified. See <xref linkend="chap-advanced-options" /> for more information.
			</para>
		</section>
	</section>
	
	<section>
		<title>Usage</title>
		
		<para>
		      We can perform a number of deployment activities with the deployment models shown earlier.
		</para>
		
		<section>
			<title>Deploying the system from scratch</title>
			<para>
				By running the following command-line instruction, the StaffTracker system can be deployed:
<screen>
$ disnix-env -s services.nix -i infrastructure.nix -d distribution.nix
</screen>
			</para>
			
			<para>
				The above instruction execute all the required steps to get the system running -- the services and their dependencies are built from source code
				on the coordinator machine, then the services and their intra-dependencies are transferred to the target machines
				in the network. Finally, the services are activated.
			</para>
		</section>
	
		<section>
			<title>Upgrading the system</title>
			
			<para>
				Upgrading a system can be done by changing the Disnix models and running <command>disnix-env</command> again.
				For example, we can open the distribution model and change the line:
<screen>
ZipcodeService = [ infrastructure.test1 ];
</screen>
			</para>
			
			<para>
				into:
<screen>
ZipcodeService = [ infrastructure.test2 ];
</screen>
				to move the <code>ZipcodeService</code> from machine <code>test1</code> to <code>test2</code>. By running the following command:
<screen>
$ disnix-env -s services.nix -i infrastructure.nix -d distribution.nix
</screen>
				Disnix upgrades the environment and only performs the steps that are necessary -- it moves the build of the <code>ZipcodeService</code>
				from the coordinator machine to <code>test2</code> and redeploys the web application front-end to connect to the new location of the
				<code>ZipcodeService</code>. All the other parts of the system will remain untouched.
			</para>
		</section>
	
		<section>
			<title>Roll back to a previous configuration</title>
			
			<para>
				As with the Nix package manager, Disnix retains older configurations by default unless they are explicitly
				garbage collected.
				If we regret the last upgrade, we can roll back to its previously deployed configuration, by running:
<screen>
$ disnix-env --rollback
</screen>
			</para>
			<para>
				Besides the last configuration, we can also roll back to any previous generation that has not been garbage
				collected yet. The following command switches the deployment to a specific generation number:
			</para>
<screen>
$ disnix-env --switch-to-generation 1
</screen>
		</section>
	
		<section>
			<title>Deploying a system and building the services on the target machines</title>
			<para>
				It may be possible that the coordinator machine is not able build services for every machine in the network
				(e.g. if a target is a <code>i686-cygwin</code> and the coordinator is a <code>i686-linux</code> machine).
				In such cases, it is also possible to perform builds on machines in the network and then copy the build results
				back to the coordinator for further use:
<screen>
$ disnix-env --build-on-targets -s services.nix -i infrastructure.nix -d distribution.nix
</screen>
				Before the actual configuration gets deployed, Disnix delegates the builds of all the services to target machines
				(instead of doing the builds itself) and retrieves the results from the target machines.
			</para>
		</section>
	
		<section>
			<title>Collecting garbage</title>
			
			<para>
				As with the standard Nix package manager, Disnix also offers an option to safely remove packages
				and their intra-dependencies that are no longer in use. The following command
				removes garbage from every machine defined in the infrastructure model:
<screen>
$ disnix-collect-garbage infrastructure.nix
</screen>
			</para>
			<para>
				By default, Disnix will not remove all its previous deployment states. In order
				to remove previous deployment states, including the corresponding garbage, the
				<option>-d</option> option can be used:
<screen>
$ disnix-collect-garbage -d infrastructure.nix
</screen>
			</para>
		</section>
	</section>
</chapter>
