<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="chap-usage">

	<title>Usage</title>

        <para>
		The models described in the previous chapter can be used to perform the <emphasis>complete</emphasis>
		deployment process of a service-oriented system or certain steps of the process
		seperately. Moreover, the models can also be used for some other purposes.
        </para>
        
	<section>
		<title>Deploying a system</title>
		<para>
			To deploy a complete system the following instruction can be run from the command-line:
		</para>
		
<screen>
$ disnix-env -s services.nix -i infrastructure.nix -d distribution.nix
</screen>

		<para>
			By executing the command above, all the services and their dependencies are compiled from source code
			on the coordinator machine, then the services and their intra-dependencies are transferred to the target machines
			in the network. Finally, the obsolete services from the previous configuration are deactivated and the
			new services are activated.
		</para>
		<para>
			If state deployment has been enabled for any of the services, then their states will be captured, transferred
			and restored if a service gets moved from one machine to another.
		</para>
		<para>
			It may be possible that the coordinator machine is not able build services for every machine in the network
			(e.g. if a target is a <code>i686-freebsd</code> and the coordinator is a <code>i686-linux</code> machine).
			In such cases it is also possible to perform builds on machines in the network and then copy the build results
			back to the coordinator for further use:
		</para>
		
<screen>
$ disnix-env --build-on-targets -s services.nix -i infrastructure.nix -d distribution.nix
</screen>
	</section>
		
	<section>
		<title>Building a system on the coordinator machine</title>
		
		<para>
			In order to build all the services from source code, the following command can be used:
		</para>
		
<screen>
$ disnix-manifest -s services.nix -i infrastructure.nix -d distribution.nix
</screen>
		
		<para>
			This command produces a <emphasis>manifest</emphasis> file, which is basically
			a more concrete version of the distribution model. This file contains references
			to the actual Nix store paths of all the build results. 
			As a side effect, all the services that are specified in the distribution model
			are built from source code.
			The manifest is also a Nix package residing in the Nix store.
			For convenience, this tool creates a symlink called <filename>result</filename> pointing
			to it.
		</para>
		
		<para>
			For instance, by querying the runtime dependencies of the generated manifest file,
			all the services including their runtime dependencies can be retrieved:
		</para>
		
<screen>
$ nix-store -qR ./result
</screen>
	</section>
	
	<section>
		<title>Building services on target machines</title>
		
		<para>
			You can also perform all the builds on the target machines and then retrieve
			back the results. The following command generates a
			<emphasis>distributed derivation</emphasis> file, which is basically
			a similar file as a manifest, except that it maps Nix store derivation
			files (low-level specifications that Nix uses to build a component) to target
			machines.
		</para>
		
<screen>
$ disnix-instantiate -s services.nix -i infrastructure.nix -d distribution.nix
</screen>
		
		<para>
			Like the manifest file, the distributed derivation file is also stored
			in the Nix store and a <filename>result</filename> symlink is stored in the
			current directory pointing to it.
		</para>
		
		<para>
			By querying the runtime dependencies of a distributed derivation file,
			all the store derivations files of the services, including their build-time
			dependencies can be retrieved:
		</para>
		
<screen>
$ nix-store -qR ./result
</screen>
		
		<para>
			The distributed derivation file can then be used to perform the builds:
		</para>

<screen>
$ disnix-build ./result
</screen>
		
		<para>
			This command distributes the store derivation file of each service and its
			dependencies to the machines in the network, then it builds them on each
			machine and finally copies the build results back into the Nix store of the 
			coordinator machine.
		</para>
	</section>
	
	<section>
		<title>Distributing services to target machines</title>
		
		<para>
			After all services have been built by invoking <command>disnix-manifest</command>,
			then the services including their runtime dependencies can be distributed
			to machines in the network by calling:
		</para>
		
<screen>
$ disnix-distribute ./result
</screen>
	</section>
	
	<section>
		<title>Deactivating obsolete services and activating services on target machines</title>
		
		<para>
		      After services have been distributed by invoking <command>disnix-distribute</command>, the
		      obsolete services can be deactivated and the new services activated by running:
		</para>
		
<screen>
$ disnix-activate ./result
</screen>
	</section>
	
	<section>
		<title>Collecting garbage</title>
		
		<para>
			Like the standard Nix, Disnix also offers an option to safely remove packages
			and their intra-dependencies that are no longer in use. The following command
			removes garbage from every machine defined in the infrastructure model:
		</para>
		
<screen>
$ disnix-collect-garbage infrastructure.nix
</screen>
		
		<para>
			By default Disnix will not remove all its previous deployment states. In order
			to remove previous deployment states, including all the garbage the
			<option>-d</option> option can be used:
		</para>
		
<screen>
$ disnix-collect-garbage -d infrastructure.nix
</screen>
	</section>
	
	<section>
		<title>Capturing the state of deployed services</title>
		
		<para>
			If state deployment has been enabled for one or more services, you can take capture their states
			and transfer them to the coordinator machine by running:
		</para>
		
<screen>
$ disnix-snapshot
</screen>
		
		<para>
			The above command takes the last executed deployment configuration, takes snapshots and only
			transfers the snapshots that have not been transferred before. This approch could serve as a backup mechanism.
		</para>
	</section>
	
	<section>
		<title>Restoring the state of deployed services</title>
		
		<para>
			Restoring the state of services for which state deployment has been enabled, can be done as follows:
		</para>
		
<screen>
$ disnix-restore
</screen>
		
		<para>
			The above command transfers the latest versions of the snapshots from the coordinator machine to the target
			machines and restores the state of all services that do not have any state deployed, i.e. a database that
			is still empty.
		</para>
		
		<para>
			The fact that only services without any state are restored, serves as a safety mechanism so that no data
			is accendentally lost.
		</para>
		
		<para>
			It may also be desirable to force all state to be restored, even for components that have some state already.
			Forcing all snapshots to be restored can be done as follows:
		</para>
		
<screen>
$ disnix-restore --no-upgrade
</screen>
	</section>
	
	<section>
		<title>Cleaning snapshots</title>
		<para>
			Every time the snapshot operation is executed, new generations of snapshots are created which are stored
			alongside older generations. Moreover, older generations of snapshots are never removed automatically.
		</para>
		<para>
			To remove older snapshot generations on the target machines, run the following command:
		</para>
<screen>
$ disnix-clean-snapshots infrastructure.nix
</screen>
		<para>
			The above command removes all but the last snapshot generation of all services. The amount of snapshot generations
			that must be kept can be raised:
		</para>
<screen>
$ disnix-clean-snapshots --keep 3 infrastructure.nix
</screen>
		<para>
			The above instruction states that the last three generations must be kept.
		</para>
		<para>
			Keep in mind that Disnix always transfers the snapshots to the coordinator machine, so there is typically little
			reason (besides improving the efficiency of the snapshot operations) to keep them on the targets. All snapshots
			on the target machines can be wiped as follows:
		</para>
<screen>
$ disnix-clean-snapshots --keep 0 infrastructure.nix
</screen>
	</section>
	
	<section>
		<title>Notes on state deployment</title>
		<para>
			Although Disnix supports state deployment, it has been disabled by default. The reason why this is the default policy
			is that its mechanisms may neither be the preferred nor the optimal way of doing it.
		</para>
		<para>
			Disnix uses Dysnomia's plugin system that invokes external tools taking care of snapshotting and restoring the state
			of the corresponding components. The good part of this approach is that it is general and works for all kinds of mutable
			components. Moreover, the tools that are consulted by the plugin system typically dump state in a portable and consistent
			format, which is also useful for a variety of reasons.
		</para>
		<para>
			However, some of the drawbacks of this approach is that the process of snapshotting and restoring portable dumps is
			typically very slow, especially for large data sets. Moreover, the snapshot tools also write dumps entirely to the filesystem
			which is not always desired.
		</para>
		<para>
			Alternative approaches of doing state deployment are the following:
		</para>
		
		<itemizedlist>
			<listitem>
				<para>
					Filesystem level snapshots. This is an approach that works typically much faster.
					However, some drawbacks of working on filesystem level is that physical state may be inconsistent (because of incomplete write operations),
					and non-portable. Also, for some types of containers, it is difficult to manage chunks of data, such as individual databases. Filesystem level
					state management is unsupported by Disnix and must be done by other means.
				</para>
			</listitem>
			<listitem>
				<para>
					Replication engines. Replication engines of DBMSes can typically move data from one machine to another much faster and more efficiently.
					Disnix does not take care of configuring a DBMS' replication engine automatically.
					Instead, while deploying a machine's configuration this feature must be explicitly enabled by the deployer.
				</para>
			</listitem>
		</itemizedlist>
	</section>
</chapter>
