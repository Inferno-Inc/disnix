<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="chap-advanced-options">

	<title>Advanced options</title>

	<section>
		<title>Configuring a custom connection protocol</title>
		
		<para>
			As mentioned before, the Disnix service consists of a core service and a protocol wrapper.
			By default, an SSH wrapper is used, but other types of wrappers can be used as well,
			such as SOAP, provided by the external <code>DisnixWebService</code> package.  
		</para>
		
		<para>
			The coordinator machine invokes an external process which performs communication with
			the Disnix service. By default <command>disnix-ssh-client</command> is consulted. A different
			client can be used by either setting the <varname>DISNIX_CLIENT_INTERFACE</varname>
			environment variable with the path to the executable or by using the
			<option>--interface</option> command-line option, for commands such as
			<command>disnix-env</command>.
		</para>
		
		<para>
			For example, by specifying:
		</para>
		
<screen>
$ export DISNIX_CLIENT_INTERFACE=disnix-soap-client
</screen>

		<para>
			The <command>disnix-soap-client</command> command is used to communicate with a remote Disnix service.
		</para>
		
		<para>
			Apart from configuring the coordinator machine, each target machine must also run the
			connection wrapper so that it can use the given protocol. Refer to the documentation
			of the extension for specific instructions.
		</para>
		
		<para>
			Another wrapper is <command>disnix-client</command> that 
			connects directly to the D-Bus system bus to invoke Disnix 
			service operations. This wrapper is useful for debugging purposes, but you cannot use this client
			for remote connections.
		</para>
		
		<para>
			In some cases, also the target property must be configured. By default, Disnix uses the
			<varname>hostname</varname> property in the infrastructure model, to determine
			how to connect to the remote Disnix service in order to perform remote deployment steps.
			This property is not always sufficient for every protocol. A web service interface may require a URL
			or a connection string may also need a port number specification.
		</para>
		<para>
			The connection attribute can be changed by either setting the <varname>DISNIX_TARGET_PROPERTY</varname>
			environment variable with the attribute name that contains the address of the remote
			Disnix service or by using the <option>--target-property</option> command-line option.
		</para>
		
		<para>
			For example, by specifying:
		</para>
		
<screen>
$ export DISNIX_TARGET_PROPERTY=sshTarget
</screen>
		
		<para>
			The <varname>sshTarget</varname> attribute defined in the infrastructure model is used
			to determine the address of the Disnix service.
		</para>
		<para>
			It is also possible to define a target property and client interface for each individual
			machine to support multi connection protocol deployment. See <xref linkend="ex-6-infrastructure-model" />
			for more information.
		</para>
	</section>
	
	<section>
		<title>Managing multiple distributed system configurations</title>
		
		<para>
			By default, Disnix assumes that the models that you are currently using represent one particular
			distributed environment. You can also use multiple profiles, which allow you to maintain
			multiple distributed system environments from one coordinator machine.
			By using the <option>--profile</option> option for the <command>disnix-env</command>
			and <command>disnix-activate</command> commands, you can specify which profile you want
			to use, so that they do not interfere with each other.
		</para>
		
		<para>
			The following instructions will install a particular distributed environment:
		</para>
		
<screen>
$ disnix-env -s my-default-services.nix -i my-default-infrastructure.nix -d my-default-distribution.nix
</screen>
		
		<para>
			By running the following command with three models of another distributed environment:
		</para>

<screen>
$ disnix-env -s my-other-services.nix -i my-other-infrastructure.nix -d my-other-distribution.nix
</screen>

		<para>
			Disnix will <emphasis>upgrade</emphasis> the previous the default environment to match the models defined
			in the other environment, which is not desirable.
			However, by using the <option>--profile</option> option Disnix
			deploys the new distributed system without looking to the default system's deployment
			state and maintains two seperate configuration next to each other:
		</para>

<screen>
$ disnix-env --profile other -s my-other-services.nix -i my-other-infrastructure.nix -d my-other-distribution.nix
</screen>

		<para>
			Besides using the <option>--profile</option> option, you can also use an environment variable:
		</para>
<screen>
$ export DISNIX_PROFILE=other
</screen>
	</section>
	
	<section>
		<title>Enabling state deployment by default</title>
		
		<para>
			If it desired to let Disnix manage state, you must annotate the corresponding services in the service model.
			However, it is also possible to override Disnix's default behaviour to enable state manage management for all
			services by default.
		</para>
		
		<para>
			Global state deployment can be enabled by providing the <option>--deploy-state</option> command-line option to
			commands such as <command>disnix-env</command> or by setting the following environment variable:
		</para>
		
<screen>
$ export DISNIX_DEPLOY_STATE=1
</screen>
	</section>
	
	<section>
		<title>Deploying target-specific services</title>
		
		<para>
			Services defined in the services model are target-agnostic by default, which means that as long as the dependencies
			remain identical, they always have the same form regardless to what machine they are deployed in the network.
			In most cases, this is considered a good thing as it makes deployment reproducible, reliable and efficient.
		</para>
		<para>
			However, in some sitations it may also be desired to build and configure services for a target machine specifically.
			An example of such a deployment scenarion is when we want to deploy a collection of Node.js web applications and an
			nginx reverse proxy in which each web application should be reached by its own unique DNS domain name
			(e.g. <code>http://webapp1.local</code>, <code>http://webapp2.local</code> etc.).
		</para>
		<para>
			If we would deploy the nginx proxies as target-agnostic services, then each of them will depend on all web applications in the
			network, including the services that are not deployed to the same machine. This in efficient for a variety of reasons --
			a machine may handle all incoming traffic including the traffic that is meant for another machine. Moreover, redeploying
			a system also becomes unnecessarily complex -- changing the configuration of a service on one particular machine implies
			reconfiguration of all nginx proxies.
		</para>
		<para>
			A dumb way to deal with this inefficiency is by defining services in the service model
			for each service and machine pair (e.g. <code>nginx-test1</code>, <code>nginx-test2</code>) and mapping them to
			their corresponding target machines in the distribution model.
		</para>
		<para>
			The downside of this approach is that it is quite tedious too maintain their configurations. We must define <code>components x machines</code>
			target-specific services. For example, if we have tens of services and tens of machines, we need to maintain hundreds of target-specific services.
		</para>
		<para>
			To alleviate this problem, target-specific services can also be generated. To accomplish this, we must first define their mappings in the distribution model: 
		</para>
		
		<example xml:id="ex-10-distribution-target-specific">
			<title>Mapping target-specific services</title>
			<programlisting>
{infrastructure}:

{
  webapp1 = [ infrastructure.test1 ];
  webapp2 = [ infrastructure.test1 ];
  webapp3 = [ infrastructure.test2 ];
  webapp4 = [ infrastructure.test2 ];
  nginx-wrapper-test1 = [ infrastructure.test1 ];
  nginx-wrapper-test2 = [ infrastructure.test2 ];
}
			</programlisting>
		</example>
		
		<para>
			In <xref linkend="ex-10-distribution-target-specific" />, we define four target-agnostic web application services and two target-specific nginx services
			that are mapped to machine <code>test1</code> and <code>test2</code>.
		</para>
		
		<example xml:id="ex-11-services-target-specific">
			<title>Generating target-specific service configurations</title>
<programlisting>
{system, pkgs, distribution, invDistribution}:

let
  customPkgs = import ../top-level/all-packages.nix {
    inherit pkgs system;
  };
in
{
  webapp1 = ...
  webapp2 = ...
  webapp3 = ...
  webapp4 = ...
} //

# Generate nginx proxy per target host

builtins.listToAttrs (map (targetName:
  let
    serviceName = "nginx-wrapper-${targetName}";
    servicesToTarget = (builtins.getAttr targetName invDistribution).services;
  in
  { name = serviceName;
    value = {
      name = serviceName;
      pkg = customPkgs.nginx-wrapper;
      # The reverse proxy depends on all services distributed to the same
      # machine, except itself (of course)
      dependsOn = builtins.removeAttrs servicesToTarget [ serviceName ];
      type = "wrapper";
    };
  }
) (builtins.attrNames invDistribution))
</programlisting>
		</example>
		
		<para>
			We can generate the corresponding target-specific services in the services model as shown in <xref linkend="ex-11-services-target-specific" />.
			To generate the nginx services, we iterate over a so-called inverse distribution model mapping targets to services
			that has been computed from the distribution model (mapping services to one or more machines in the network).
		</para>
		<para>
			The inverse distribution model is basically just the infrastructure model in which each target attribute set
			has been augmented with a services attribute containing the properties of the services that have been deployed
			to it. The <code>services</code> attribute refers to an attribute set in which each key is the name of the service and each
			value the service configuration properties defined in the services model.
		</para>
		<para>
			For example, if we refer to <code>invDistribution.test1.services</code> we get all the configurations of the services
			that are deployed to machine <code>test1</code>. If we remove the reference to the nginx reverse proxy, we can pass this
			entire attribute set as inter-dependencies to configure the reverse proxy on machine <code>test1</code>.
			(The reason why we remove the reverse proxy as a dependency is because it is meaningless to let it refer to itself.
			Furthermore, this would also cause infinite recursion).
		</para>
	</section>
</chapter>
